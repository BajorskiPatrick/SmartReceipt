/* tslint:disable */
/* eslint-disable */
/**
 * Smart Receipt API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { AuthResponse } from '../models';
// @ts-ignore
import { Category } from '../models';
// @ts-ignore
import { DashboardData } from '../models';
// @ts-ignore
import { ErrorResponse } from '../models';
// @ts-ignore
import { ExpenseDetails } from '../models';
// @ts-ignore
import { ExpenseItem } from '../models';
// @ts-ignore
import { ExpenseSummaryPage } from '../models';
// @ts-ignore
import { MonthlyBudget } from '../models';
// @ts-ignore
import { NewCategory } from '../models';
// @ts-ignore
import { NewExpense } from '../models';
// @ts-ignore
import { NewExpenseItem } from '../models';
// @ts-ignore
import { NewMonthlyBudget } from '../models';
// @ts-ignore
import { NewOcrExpense } from '../models';
// @ts-ignore
import { NewUserByAdmin } from '../models';
// @ts-ignore
import { OcrExpense } from '../models';
// @ts-ignore
import { RefreshedToken } from '../models';
// @ts-ignore
import { UserLogin } from '../models';
// @ts-ignore
import { UserRegistration } from '../models';
// @ts-ignore
import { UserResponse } from '../models';
/**
 * MainAppApi - axios parameter creator
 * @export
 */
export const MainAppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Manually add expense
         * @param {NewExpense} newExpense 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addManualExpense: async (newExpense: NewExpense, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newExpense' is not null or undefined
            assertParamExists('addManualExpense', 'newExpense', newExpense)
            const localVarPath = `/expenses/manual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newExpense, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new expense category
         * @param {NewCategory} newCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (newCategory: NewCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newCategory' is not null or undefined
            assertParamExists('createCategory', 'newCategory', newCategory)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new user budget
         * @param {NewMonthlyBudget} newMonthlyBudget 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserBudget: async (newMonthlyBudget: NewMonthlyBudget, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newMonthlyBudget' is not null or undefined
            assertParamExists('createUserBudget', 'newMonthlyBudget', newMonthlyBudget)
            const localVarPath = `/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newMonthlyBudget, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new user (admin only)
         * @param {NewUserByAdmin} newUserByAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByAdmin: async (newUserByAdmin: NewUserByAdmin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newUserByAdmin' is not null or undefined
            assertParamExists('createUserByAdmin', 'newUserByAdmin', newUserByAdmin)
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newUserByAdmin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a category. Sets the \'deleted\' flag to true so it is not returned as an available choice, but old expenses do not lose their category.
         * @summary Delete category
         * @param {string} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCategory', 'categoryId', categoryId)
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the expense along with all its items.
         * @summary Delete expense
         * @param {string} expenseId ID of the expense to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExpense: async (expenseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expenseId' is not null or undefined
            assertParamExists('deleteExpense', 'expenseId', expenseId)
            const localVarPath = `/expenses/{expenseId}`
                .replace(`{${"expenseId"}}`, encodeURIComponent(String(expenseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a single item from the expense. The total amount and item count are automatically recalculated.
         * @summary Delete specific expense item
         * @param {string} expenseId Expense ID
         * @param {string} itemId ID of the item to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExpenseItem: async (expenseId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expenseId' is not null or undefined
            assertParamExists('deleteExpenseItem', 'expenseId', expenseId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteExpenseItem', 'itemId', itemId)
            const localVarPath = `/expenses/{expenseId}/items/{itemId}`
                .replace(`{${"expenseId"}}`, encodeURIComponent(String(expenseId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user (admin only)
         * @param {string} userId ID of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserByAdmin: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserByAdmin', 'userId', userId)
            const localVarPath = `/admin/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users (admin only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of user-defined expense categories (e.g., for the dropdown when manually adding an expense or filtering).
         * @summary Get all user categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all data needed for the initial dashboard load for a given month (KPI, Widget 1 - categories, Widget 2 - trend).
         * @summary Get aggregated dashboard data
         * @param {number} year Year for analysis
         * @param {number} month Month for analysis (1-12). The 6-month trend will be calculated backwards from this date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardData: async (year: number, month: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            assertParamExists('getDashboardData', 'year', year)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getDashboardData', 'month', month)
            const localVarPath = `/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the full expense object, including a list of all its items. Used when the user clicks \'Details\' on the list.
         * @summary Get full expense details (with items)
         * @param {string} expenseId ID of the expense to fetch details for
         * @param {string} [categoryId] Category which expense items we want to see in details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpenseDetails: async (expenseId: string, categoryId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expenseId' is not null or undefined
            assertParamExists('getExpenseDetails', 'expenseId', expenseId)
            const localVarPath = `/expenses/{expenseId}`
                .replace(`{${"expenseId"}}`, encodeURIComponent(String(expenseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of expenses for the logged-in user. Key endpoint for Widget 3 on the dashboard. Supports filtering by date (year/month) and category. Supports pagination by default.
         * @summary Get expense history (for Widget 3)
         * @param {number} year Year for which expenses are fetched
         * @param {number} month Month (1-12) for which expenses are fetched
         * @param {string} [categoryId] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpensesList: async (year: number, month: number, categoryId?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            assertParamExists('getExpensesList', 'year', year)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getExpensesList', 'month', month)
            const localVarPath = `/expenses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user budget (for this month)
         * @param {number} year Budget year
         * @param {number} month Budget month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBudget: async (year: number, month: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            assertParamExists('getUserBudget', 'year', year)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getUserBudget', 'month', month)
            const localVarPath = `/budgets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User login
         * @param {UserLogin} userLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (userLogin: UserLogin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLogin' is not null or undefined
            assertParamExists('loginUser', 'userLogin', userLogin)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLogin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register new user
         * @param {UserRegistration} userRegistration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (userRegistration: UserRegistration, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRegistration' is not null or undefined
            assertParamExists('registerUser', 'userRegistration', userRegistration)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegistration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates category information - name and description
         * @summary Update category
         * @param {string} categoryId ID of the category to update
         * @param {NewCategory} newCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updaetCategory: async (categoryId: string, newCategory: NewCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('updaetCategory', 'categoryId', categoryId)
            // verify required parameter 'newCategory' is not null or undefined
            assertParamExists('updaetCategory', 'newCategory', newCategory)
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates basic information about the expense and all its items. The items list is replaced with the new one.
         * @summary Update entire expense
         * @param {string} expenseId ID of the expense to update
         * @param {NewExpense} newExpense 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExpense: async (expenseId: string, newExpense: NewExpense, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expenseId' is not null or undefined
            assertParamExists('updateExpense', 'expenseId', expenseId)
            // verify required parameter 'newExpense' is not null or undefined
            assertParamExists('updateExpense', 'newExpense', newExpense)
            const localVarPath = `/expenses/{expenseId}`
                .replace(`{${"expenseId"}}`, encodeURIComponent(String(expenseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newExpense, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates details of a single item in the expense (e.g., product name, price, category).
         * @summary Update specific expense item
         * @param {string} expenseId Expense ID
         * @param {string} itemId ID of the item to update
         * @param {NewExpenseItem} newExpenseItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExpenseItem: async (expenseId: string, itemId: string, newExpenseItem: NewExpenseItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expenseId' is not null or undefined
            assertParamExists('updateExpenseItem', 'expenseId', expenseId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('updateExpenseItem', 'itemId', itemId)
            // verify required parameter 'newExpenseItem' is not null or undefined
            assertParamExists('updateExpenseItem', 'newExpenseItem', newExpenseItem)
            const localVarPath = `/expenses/{expenseId}/items/{itemId}`
                .replace(`{${"expenseId"}}`, encodeURIComponent(String(expenseId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newExpenseItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user budget
         * @param {string} budgetId 
         * @param {NewMonthlyBudget} newMonthlyBudget 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserBudget: async (budgetId: string, newMonthlyBudget: NewMonthlyBudget, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('updateUserBudget', 'budgetId', budgetId)
            // verify required parameter 'newMonthlyBudget' is not null or undefined
            assertParamExists('updateUserBudget', 'newMonthlyBudget', newMonthlyBudget)
            const localVarPath = `/budgets/{budgetId}`
                .replace(`{${"budgetId"}}`, encodeURIComponent(String(budgetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newMonthlyBudget, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user details (admin only)
         * @param {string} userId ID of the user to update
         * @param {NewUserByAdmin} newUserByAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserByAdmin: async (userId: string, newUserByAdmin: NewUserByAdmin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserByAdmin', 'userId', userId)
            // verify required parameter 'newUserByAdmin' is not null or undefined
            assertParamExists('updateUserByAdmin', 'newUserByAdmin', newUserByAdmin)
            const localVarPath = `/admin/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newUserByAdmin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint accepts a receipt image. The backend sends it to the AI module for data extraction (OCR) and categorization, then returns an expense ready for the user to accept and add.
         * @summary Upload receipt image for processing
         * @param {File} [image] Receipt image file
         * @param {NewOcrExpense} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadReceipt: async (image?: File, data?: NewOcrExpense, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/expenses/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (data !== undefined) { 
                localVarFormParams.append('data', new Blob([JSON.stringify(data)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh user token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenRefresh: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MainAppApi - functional programming interface
 * @export
 */
export const MainAppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MainAppApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Manually add expense
         * @param {NewExpense} newExpense 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addManualExpense(newExpense: NewExpense, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpenseDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addManualExpense(newExpense, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.addManualExpense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create new expense category
         * @param {NewCategory} newCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(newCategory: NewCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(newCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.createCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create new user budget
         * @param {NewMonthlyBudget} newMonthlyBudget 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserBudget(newMonthlyBudget: NewMonthlyBudget, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonthlyBudget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserBudget(newMonthlyBudget, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.createUserBudget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create new user (admin only)
         * @param {NewUserByAdmin} newUserByAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserByAdmin(newUserByAdmin: NewUserByAdmin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserByAdmin(newUserByAdmin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.createUserByAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a category. Sets the \'deleted\' flag to true so it is not returned as an available choice, but old expenses do not lose their category.
         * @summary Delete category
         * @param {string} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.deleteCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the expense along with all its items.
         * @summary Delete expense
         * @param {string} expenseId ID of the expense to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExpense(expenseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExpense(expenseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.deleteExpense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a single item from the expense. The total amount and item count are automatically recalculated.
         * @summary Delete specific expense item
         * @param {string} expenseId Expense ID
         * @param {string} itemId ID of the item to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExpenseItem(expenseId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExpenseItem(expenseId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.deleteExpenseItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete user (admin only)
         * @param {string} userId ID of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserByAdmin(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserByAdmin(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.deleteUserByAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users (admin only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.getAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of user-defined expense categories (e.g., for the dropdown when manually adding an expense or filtering).
         * @summary Get all user categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.getCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all data needed for the initial dashboard load for a given month (KPI, Widget 1 - categories, Widget 2 - trend).
         * @summary Get aggregated dashboard data
         * @param {number} year Year for analysis
         * @param {number} month Month for analysis (1-12). The 6-month trend will be calculated backwards from this date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardData(year: number, month: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardData(year, month, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.getDashboardData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches the full expense object, including a list of all its items. Used when the user clicks \'Details\' on the list.
         * @summary Get full expense details (with items)
         * @param {string} expenseId ID of the expense to fetch details for
         * @param {string} [categoryId] Category which expense items we want to see in details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpenseDetails(expenseId: string, categoryId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpenseDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpenseDetails(expenseId, categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.getExpenseDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of expenses for the logged-in user. Key endpoint for Widget 3 on the dashboard. Supports filtering by date (year/month) and category. Supports pagination by default.
         * @summary Get expense history (for Widget 3)
         * @param {number} year Year for which expenses are fetched
         * @param {number} month Month (1-12) for which expenses are fetched
         * @param {string} [categoryId] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpensesList(year: number, month: number, categoryId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpenseSummaryPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpensesList(year, month, categoryId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.getExpensesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current user budget (for this month)
         * @param {number} year Budget year
         * @param {number} month Budget month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBudget(year: number, month: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonthlyBudget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBudget(year, month, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.getUserBudget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User login
         * @param {UserLogin} userLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(userLogin: UserLogin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(userLogin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.loginUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.logoutUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register new user
         * @param {UserRegistration} userRegistration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(userRegistration: UserRegistration, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(userRegistration, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.registerUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates category information - name and description
         * @summary Update category
         * @param {string} categoryId ID of the category to update
         * @param {NewCategory} newCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updaetCategory(categoryId: string, newCategory: NewCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updaetCategory(categoryId, newCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.updaetCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates basic information about the expense and all its items. The items list is replaced with the new one.
         * @summary Update entire expense
         * @param {string} expenseId ID of the expense to update
         * @param {NewExpense} newExpense 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExpense(expenseId: string, newExpense: NewExpense, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpenseDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExpense(expenseId, newExpense, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.updateExpense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates details of a single item in the expense (e.g., product name, price, category).
         * @summary Update specific expense item
         * @param {string} expenseId Expense ID
         * @param {string} itemId ID of the item to update
         * @param {NewExpenseItem} newExpenseItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExpenseItem(expenseId: string, itemId: string, newExpenseItem: NewExpenseItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpenseItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExpenseItem(expenseId, itemId, newExpenseItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.updateExpenseItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user budget
         * @param {string} budgetId 
         * @param {NewMonthlyBudget} newMonthlyBudget 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserBudget(budgetId: string, newMonthlyBudget: NewMonthlyBudget, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonthlyBudget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserBudget(budgetId, newMonthlyBudget, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.updateUserBudget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user details (admin only)
         * @param {string} userId ID of the user to update
         * @param {NewUserByAdmin} newUserByAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserByAdmin(userId: string, newUserByAdmin: NewUserByAdmin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserByAdmin(userId, newUserByAdmin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.updateUserByAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint accepts a receipt image. The backend sends it to the AI module for data extraction (OCR) and categorization, then returns an expense ready for the user to accept and add.
         * @summary Upload receipt image for processing
         * @param {File} [image] Receipt image file
         * @param {NewOcrExpense} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadReceipt(image?: File, data?: NewOcrExpense, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OcrExpense>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadReceipt(image, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.uploadReceipt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh user token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userTokenRefresh(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshedToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userTokenRefresh(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MainAppApi.userTokenRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MainAppApi - factory interface
 * @export
 */
export const MainAppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MainAppApiFp(configuration)
    return {
        /**
         * 
         * @summary Manually add expense
         * @param {NewExpense} newExpense 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addManualExpense(newExpense: NewExpense, options?: any): AxiosPromise<ExpenseDetails> {
            return localVarFp.addManualExpense(newExpense, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new expense category
         * @param {NewCategory} newCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(newCategory: NewCategory, options?: any): AxiosPromise<Category> {
            return localVarFp.createCategory(newCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new user budget
         * @param {NewMonthlyBudget} newMonthlyBudget 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserBudget(newMonthlyBudget: NewMonthlyBudget, options?: any): AxiosPromise<MonthlyBudget> {
            return localVarFp.createUserBudget(newMonthlyBudget, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new user (admin only)
         * @param {NewUserByAdmin} newUserByAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByAdmin(newUserByAdmin: NewUserByAdmin, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.createUserByAdmin(newUserByAdmin, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a category. Sets the \'deleted\' flag to true so it is not returned as an available choice, but old expenses do not lose their category.
         * @summary Delete category
         * @param {string} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(categoryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the expense along with all its items.
         * @summary Delete expense
         * @param {string} expenseId ID of the expense to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExpense(expenseId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteExpense(expenseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a single item from the expense. The total amount and item count are automatically recalculated.
         * @summary Delete specific expense item
         * @param {string} expenseId Expense ID
         * @param {string} itemId ID of the item to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExpenseItem(expenseId: string, itemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteExpenseItem(expenseId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user (admin only)
         * @param {string} userId ID of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserByAdmin(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserByAdmin(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users (admin only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: any): AxiosPromise<Array<UserResponse>> {
            return localVarFp.getAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of user-defined expense categories (e.g., for the dropdown when manually adding an expense or filtering).
         * @summary Get all user categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all data needed for the initial dashboard load for a given month (KPI, Widget 1 - categories, Widget 2 - trend).
         * @summary Get aggregated dashboard data
         * @param {number} year Year for analysis
         * @param {number} month Month for analysis (1-12). The 6-month trend will be calculated backwards from this date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardData(year: number, month: number, options?: any): AxiosPromise<DashboardData> {
            return localVarFp.getDashboardData(year, month, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the full expense object, including a list of all its items. Used when the user clicks \'Details\' on the list.
         * @summary Get full expense details (with items)
         * @param {string} expenseId ID of the expense to fetch details for
         * @param {string} [categoryId] Category which expense items we want to see in details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpenseDetails(expenseId: string, categoryId?: string, options?: any): AxiosPromise<ExpenseDetails> {
            return localVarFp.getExpenseDetails(expenseId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of expenses for the logged-in user. Key endpoint for Widget 3 on the dashboard. Supports filtering by date (year/month) and category. Supports pagination by default.
         * @summary Get expense history (for Widget 3)
         * @param {number} year Year for which expenses are fetched
         * @param {number} month Month (1-12) for which expenses are fetched
         * @param {string} [categoryId] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpensesList(year: number, month: number, categoryId?: string, page?: number, size?: number, options?: any): AxiosPromise<ExpenseSummaryPage> {
            return localVarFp.getExpensesList(year, month, categoryId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user budget (for this month)
         * @param {number} year Budget year
         * @param {number} month Budget month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBudget(year: number, month: number, options?: any): AxiosPromise<MonthlyBudget> {
            return localVarFp.getUserBudget(year, month, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User login
         * @param {UserLogin} userLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(userLogin: UserLogin, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.loginUser(userLogin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any): AxiosPromise<void> {
            return localVarFp.logoutUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register new user
         * @param {UserRegistration} userRegistration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(userRegistration: UserRegistration, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.registerUser(userRegistration, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates category information - name and description
         * @summary Update category
         * @param {string} categoryId ID of the category to update
         * @param {NewCategory} newCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updaetCategory(categoryId: string, newCategory: NewCategory, options?: any): AxiosPromise<Category> {
            return localVarFp.updaetCategory(categoryId, newCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates basic information about the expense and all its items. The items list is replaced with the new one.
         * @summary Update entire expense
         * @param {string} expenseId ID of the expense to update
         * @param {NewExpense} newExpense 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExpense(expenseId: string, newExpense: NewExpense, options?: any): AxiosPromise<ExpenseDetails> {
            return localVarFp.updateExpense(expenseId, newExpense, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates details of a single item in the expense (e.g., product name, price, category).
         * @summary Update specific expense item
         * @param {string} expenseId Expense ID
         * @param {string} itemId ID of the item to update
         * @param {NewExpenseItem} newExpenseItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExpenseItem(expenseId: string, itemId: string, newExpenseItem: NewExpenseItem, options?: any): AxiosPromise<ExpenseItem> {
            return localVarFp.updateExpenseItem(expenseId, itemId, newExpenseItem, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user budget
         * @param {string} budgetId 
         * @param {NewMonthlyBudget} newMonthlyBudget 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserBudget(budgetId: string, newMonthlyBudget: NewMonthlyBudget, options?: any): AxiosPromise<MonthlyBudget> {
            return localVarFp.updateUserBudget(budgetId, newMonthlyBudget, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user details (admin only)
         * @param {string} userId ID of the user to update
         * @param {NewUserByAdmin} newUserByAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserByAdmin(userId: string, newUserByAdmin: NewUserByAdmin, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.updateUserByAdmin(userId, newUserByAdmin, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint accepts a receipt image. The backend sends it to the AI module for data extraction (OCR) and categorization, then returns an expense ready for the user to accept and add.
         * @summary Upload receipt image for processing
         * @param {File} [image] Receipt image file
         * @param {NewOcrExpense} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadReceipt(image?: File, data?: NewOcrExpense, options?: any): AxiosPromise<OcrExpense> {
            return localVarFp.uploadReceipt(image, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh user token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokenRefresh(options?: any): AxiosPromise<RefreshedToken> {
            return localVarFp.userTokenRefresh(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MainAppApi - object-oriented interface
 * @export
 * @class MainAppApi
 * @extends {BaseAPI}
 */
export class MainAppApi extends BaseAPI {
    /**
     * 
     * @summary Manually add expense
     * @param {NewExpense} newExpense 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public addManualExpense(newExpense: NewExpense, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).addManualExpense(newExpense, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new expense category
     * @param {NewCategory} newCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public createCategory(newCategory: NewCategory, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).createCategory(newCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new user budget
     * @param {NewMonthlyBudget} newMonthlyBudget 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public createUserBudget(newMonthlyBudget: NewMonthlyBudget, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).createUserBudget(newMonthlyBudget, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new user (admin only)
     * @param {NewUserByAdmin} newUserByAdmin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public createUserByAdmin(newUserByAdmin: NewUserByAdmin, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).createUserByAdmin(newUserByAdmin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a category. Sets the \'deleted\' flag to true so it is not returned as an available choice, but old expenses do not lose their category.
     * @summary Delete category
     * @param {string} categoryId Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public deleteCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).deleteCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the expense along with all its items.
     * @summary Delete expense
     * @param {string} expenseId ID of the expense to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public deleteExpense(expenseId: string, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).deleteExpense(expenseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a single item from the expense. The total amount and item count are automatically recalculated.
     * @summary Delete specific expense item
     * @param {string} expenseId Expense ID
     * @param {string} itemId ID of the item to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public deleteExpenseItem(expenseId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).deleteExpenseItem(expenseId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user (admin only)
     * @param {string} userId ID of the user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public deleteUserByAdmin(userId: string, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).deleteUserByAdmin(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users (admin only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public getAllUsers(options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).getAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of user-defined expense categories (e.g., for the dropdown when manually adding an expense or filtering).
     * @summary Get all user categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public getCategories(options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).getCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all data needed for the initial dashboard load for a given month (KPI, Widget 1 - categories, Widget 2 - trend).
     * @summary Get aggregated dashboard data
     * @param {number} year Year for analysis
     * @param {number} month Month for analysis (1-12). The 6-month trend will be calculated backwards from this date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public getDashboardData(year: number, month: number, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).getDashboardData(year, month, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the full expense object, including a list of all its items. Used when the user clicks \'Details\' on the list.
     * @summary Get full expense details (with items)
     * @param {string} expenseId ID of the expense to fetch details for
     * @param {string} [categoryId] Category which expense items we want to see in details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public getExpenseDetails(expenseId: string, categoryId?: string, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).getExpenseDetails(expenseId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of expenses for the logged-in user. Key endpoint for Widget 3 on the dashboard. Supports filtering by date (year/month) and category. Supports pagination by default.
     * @summary Get expense history (for Widget 3)
     * @param {number} year Year for which expenses are fetched
     * @param {number} month Month (1-12) for which expenses are fetched
     * @param {string} [categoryId] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public getExpensesList(year: number, month: number, categoryId?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).getExpensesList(year, month, categoryId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user budget (for this month)
     * @param {number} year Budget year
     * @param {number} month Budget month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public getUserBudget(year: number, month: number, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).getUserBudget(year, month, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User login
     * @param {UserLogin} userLogin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public loginUser(userLogin: UserLogin, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).loginUser(userLogin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public logoutUser(options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).logoutUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register new user
     * @param {UserRegistration} userRegistration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public registerUser(userRegistration: UserRegistration, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).registerUser(userRegistration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates category information - name and description
     * @summary Update category
     * @param {string} categoryId ID of the category to update
     * @param {NewCategory} newCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public updaetCategory(categoryId: string, newCategory: NewCategory, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).updaetCategory(categoryId, newCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates basic information about the expense and all its items. The items list is replaced with the new one.
     * @summary Update entire expense
     * @param {string} expenseId ID of the expense to update
     * @param {NewExpense} newExpense 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public updateExpense(expenseId: string, newExpense: NewExpense, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).updateExpense(expenseId, newExpense, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates details of a single item in the expense (e.g., product name, price, category).
     * @summary Update specific expense item
     * @param {string} expenseId Expense ID
     * @param {string} itemId ID of the item to update
     * @param {NewExpenseItem} newExpenseItem 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public updateExpenseItem(expenseId: string, itemId: string, newExpenseItem: NewExpenseItem, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).updateExpenseItem(expenseId, itemId, newExpenseItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user budget
     * @param {string} budgetId 
     * @param {NewMonthlyBudget} newMonthlyBudget 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public updateUserBudget(budgetId: string, newMonthlyBudget: NewMonthlyBudget, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).updateUserBudget(budgetId, newMonthlyBudget, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user details (admin only)
     * @param {string} userId ID of the user to update
     * @param {NewUserByAdmin} newUserByAdmin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public updateUserByAdmin(userId: string, newUserByAdmin: NewUserByAdmin, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).updateUserByAdmin(userId, newUserByAdmin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint accepts a receipt image. The backend sends it to the AI module for data extraction (OCR) and categorization, then returns an expense ready for the user to accept and add.
     * @summary Upload receipt image for processing
     * @param {File} [image] Receipt image file
     * @param {NewOcrExpense} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public uploadReceipt(image?: File, data?: NewOcrExpense, options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).uploadReceipt(image, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh user token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MainAppApi
     */
    public userTokenRefresh(options?: RawAxiosRequestConfig) {
        return MainAppApiFp(this.configuration).userTokenRefresh(options).then((request) => request(this.axios, this.basePath));
    }
}

